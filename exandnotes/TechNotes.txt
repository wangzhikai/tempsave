build mozilla FF 
./mach build 

=========  
JMC parameters

-XX:+UnlockCommercialFeatures -XX:+FlightRecorder
=============================================
/**
 * Created by zwang on 10/24/14.
 *
 * Notes:
 *
 * - Disambiguation of 'chapters reorder'.
 *  Legacy studio behavior, given a single chapter project. Folder structure [F1  [F2  C1]]. | is move destination.
 *  [F1 [F2 | C1]] leads to [F1 [F2 C1]] NO CHANGE
 *  [F1 | [F2 C1]] leads to [F1 C1 [F2]]
 *  |[F1 [F2 C1]] leads to C1 [F1 [F2]]
 *  [F1 [F2 C1|]|]| leads to [F1 [F2 C1]] NO CHANGE
 *  So in this test file, we only verify chapter order against chapter, not order against folder, unless DC provides 'chapter folder' API.
 *  Another example, when try to move C1 after C2, in structure C1 [F1 [F2 C2]] [F3 [F4]].
 *  So for any destination, after moving.
 *  - if there is a 'next' chapter, we take the same folder as the next.
 *  - if there is no 'next', any folder will suffice, given the moved chapter is the last chapter.
 *  In tests, we simply use the goal chapter's folder for convenience.
 *
 * - Middle: we consider it is the element at size() div 2 + 1. Eg. five chapters, the middle is No.3. Four, we get No.3.
 *   Two, we get No.2. One, we get No.1.
 *
 */
/**
 * TODO DONE Map getAllChapters
 * TODO DONE deleteAllChapters
 * TODO DONE print chapters [name,id] other than [id] only to assure the initial order is as per order created. Need peep UI.
 * TODO DONE QUESTION, will valueSet() keep the order, Map<K,V> does not have valueSet(), has values() returns instanceof List<V>.
 * TODO DONE TASK Move 1st chapter to the last position
 * TODO DONE Change all Queues to LinkedList
 * TODO DONE TASK Move the last chapter to the top position.
 * TODO DONE Move middle chapter to be last
 * TODO DONE Move middle chapter to be first. Valid case.
 * TODO DONE QUESTION Disambiguation of 'chapters reorder'.
 * Legacy studio behavior, given a single chapter project. Folder structure [F1  [F2  C1]]. | is move destination.
 * [F1 [F2 | C1]] leads to [F1 [F2 C1]] NO CHANGE
 * [F1 | [F2 C1]] leads to [F1 C1 [F2]]
 * |[F1 [F2 C1]] leads to C1 [F1 [F2]]
 * [F1 [F2 C1|]|]| leads to [F1 [F2 C1]] NO CHANGE
 * So in this test file, we only verify chapter order against chapter, not order against folder, unless DC provides 'chapter folder' API.
 * Another example, when try to move C1 after C2, in structure C1 [F1 [F2 C2]] [F3 [F4]].
 * So for any destination, after moving.
 * - if there is a 'next' chapter, we take the same folder as the next.
 * - if there is no 'next', any folder will suffice, given the moved chapter is the last chapter.
 * TODO DONE Refactor existing tests according to new move constraint, discussed as the above paragraph.
 * TODO DONE Coding style according to code review meeting:
 * 1. Create separate utility class.
 * 2. Follow given/when/then concept.
 * 3. Use “static” keyword wisely.
 * 4. Make sure one test does only ONE thing.
 * 5. Avoid extension of classes.
 * 6. Extra line between two functions.
 * TODO DONE Move the first chapter down bellow a chapter that is in a folder. Valid case.
 * TODO DONE Move last chapter that is in folder to the very top. Valid case.
 * TODO DONE Move middle chapter that is in folder to the very top. Valid case.
 * TODO DONE Re-order pages that are in folders. Example: Page1, Page2, Page3 are in folders. Move Page3 after Page1. Valid case.
 * TODO DONE Move a page between pages in a folder. Valid case.
 * TODO DONE Re-oder chapters in a project that contains multilevel empty folders. Valid case.
 * TODO DONE Do re-order with undo/redo combination. Valid case.
 * TODO DONE Validation error should be thrown for invalid chapterId and invalid folderId. Invalid case.
 * TODO DONE Try to change chapter name. Expected: validation error. Invalid case.
 * TODO DONE Use complex idoc with lot of chapters/folders.
 *
 *
 *
 * TODO proof read comments, clean up.
 *
 *
 *
 * TODO CONSIDERING Stress test MAX number of regular pages in a project in localhost.
 * TODO CONSIDERING Create a folder using REST API other than legacy studio? Possible?
 * TODO CONSIDERING Make log4j run properly in IntelliJ console test.
 * TODO QUESTION, Java pass 1.func(Type var )const, 2.func (Type const&  var), 3.func( Type & const var ), 4.func(const Type var ) equivalences?
 * TODO QUESTION, It looks like testNG did not join the test thread, or handle the 1 and 2 file descriptors properly (flush all the buffers, before exit). Is this the reason we miss some console output (System.out.print) in Intellij, or the finger should point to Intellij?
 */
 
 20141031

================================
# touch hyphen
touch '-'

================================

//TODO DONE unsupportedTests this file's package is wrong, shoule be scenarioTests, so we can re-use its prop_t
//import com.irise.testng.unsupportedTests.CreateActionTest
//And it may always good to put constants as static final or load from a property files
//import com.irise.testng.scenarioTests.CreateActionTest
/**
 * Created by zwang on 10/10/14.
 */
/**
 * TODO DONE Change all .equals() to .toString().equals()
 * TODO DONE INFO Widget CONDITIONAL_HTML cannot be created without children
 * TODO DONE QUESTION println ''.getClass() class java.lang.String
 * TODO DONE INFO how cHTML is created
 // Create conditional HTML, add buttons to it
 json {
    type "CONDITIONAL_HTML"
    children([
        { sourceWidgetId childrenWidgetsSet[0]["id"] },
        { id childrenWidgetsSet[0]["id"] }
    ])
 }
 println prettyPrint(json.toString())
 {
    "type": "CONDITIONAL_HTML",
    "children": [
        {   "sourceWidgetId": "10622ed5f6e84d408fc78324403266b6"},
        {   "id": "10622ed5f6e84d408fc78324403266b6"    }
    ]
 }
 resp = widget.createShowCreateId(projectIdInTest, json.toString())
 def conditionalHTMLWidgetId = resp.responseData.createId
 NOTE: the two children look must be of the same type. QUESTION ? !
 * TODO DONE if CONDITIONAL_HTML remove containerKey QUESTION ? !
 * static def getWidgetMap (containerKey,widgetNodeInResp,requiredRootAttributes, requiredProps, newRootValues,newPropValues) {
 * ﻿TODO DONE TASK CURRENT Verify that CHTML or its view can be locked, valid case.
 * TODO DONE TASK Verify, in the lock aspect, given a stack of transactions, 'undo' will always revoke the top one and pop the stack.  Redo has its stack of 'undos', as per discussion.
 ﻿* TODO DONE TASK Verify copying of chapter also copies the Lock property of widgets, valid case.
 * TODO DONE Find nodes by name keyword in content resp. findNodesByNameKeywordToMap (node, keyword)
 * TODO DONE TASK Verify that the locked widget can be associated to the actions, valid case.
 *       for (def chap : resp.data.chapters) {
 //TODO DONE Test isTreeBranchValid (propVector, node)
 for (def chap : resp.data.chapters)
     println "isTreeBranchValid (['content','id'], node) = "+isTreeBranchValid (["content","id"], chap)
     println "isTreeBranchValid (['ctent','id'], node) = "+isTreeBranchValid (['ctent','id'], chap)
     println "isTreeBranchValid (['content','iid'], node) = "+isTreeBranchValid (['content','iid'], chap)
     println "isTreeBranchValid ([''], node) = "+isTreeBranchValid ([''], chap)
 OUTPUT
 isTreeBranchValid (['content','id'], node) = true
 isTreeBranchValid (['ctent','id'], node) = false
 isTreeBranchValid (['content','iid'], node) = false
 isTreeBranchValid ([''], node) = false
 //TODO DONE Test static def prettyRespData (resp)
 * TODO DONE TASK Verify creating actions from locked widget, valid case. Actions TBD?
 * TODO DONE INFO resp instanceof roovyx.net.http.HttpResponseDecorator
 //TODO DONE QUESTION What indicates a widget is blacklisted? The answer if a chapter not supported, its widgets if any is 'blacklisted'.
 //TODO DONE QUESTION Why Some can be locked some not? As above. So the UI layer is supposed to fence off the illegal request.
 * TODO DONE TASK Verify that you cannot lock blacklist items ( menu, tables....), invalid case.
 * TODO DONE USE the required properties to create chapter, page, master etc.
 * TODO DONE TASK Verify that you can lock localRef, valid case. localRef TBD
 *
 *
 *
 * TODO TASK Verify that the locked widget can be associated to the actions, valid case.  Reopen to use trigger API.
 * TODO TASK Clean up this file as per stand-up discussion.
 *
 // TODO QUESTION CAN NOT DROP  master1(master) to page1, don't have to commit this part.
 //        // Failed
 //        sourceChapterId = chapterIds.get('master1')
 //        targetContentId = contentIds.get('page1')
 //        resp = g('chapter').dropMasterOnPage(projectIdInTest, chapterIds.get('page1'),new JsonBuilder([sourceId:sourceChapterId,targetId:targetContentId,x:200,y:200]).toString())
 //        assertEquals(resp.status, 201, "Failed to drop Master on Page " + resp.responseData["failures"])
 // TODO QUESTION NOTE local_ref at this phase 20141023 is not whitelisted
 ﻿* TODO QUESTION At the service layer, do (x,y) change as per the new container?
 * TODO QUESTION Unlock CHTML did not unlock children
 * Gist:
 * 1. Locked will be a required property
 * 2. For container's children, lock property is examined in UI aspect.
 * TODO BUG TASK Verify that the locked widgets can be moved, valid case. To change (x,y) or to move to a different container.
 *
 // TODO DONE his snipet works, the chtml would contain two same type element as c (batch1[0])
 def c=[]
 int i =0
 for (def v : batch1) {
 c += [sourceWidgetId:v.getKey()]
 c += [id:v.getKey()]
 //            json {
 //                type "CONDITIONAL_HTML"
 //                name "some name"
 //                children([
 //                        { sourceWidgetId v.getKey() },
 //                        { id v.getKey() }
 //                ])
 //            }
 if (++i ==1)
 break;

 }
 def m = [:]
 m['type'] = "CONDITIONAL_HTML"
 m['name'] = "C1"
 m['children'] = c
 m['properties'] = ["locked": "false", "z": "7", "rules": "None", "y": "10", "x": "10"]
 json = new JsonBuilder(m)
 println prettyPrint(json.toString())
 //                {
 //                    "type": "CONDITIONAL_HTML",
 //                    "name": "C1",
 //                    "children": [
 //                        {
 //                            "sourceWidgetId": "85855789400643c6ba77765984d0e2b3"
 //                        },
 //                        {
 //                            "id": "85855789400643c6ba77765984d0e2b3"
 //                        }
 //                ],
 //                    "properties": {
 //                    "locked": "false",
 //                    "z": "7",
 //                    "rules": "None",
 //                    "y": "10",
 //                    "x": "10"
 //                }
 //                }
 //POST rest.post("projects/${projectId}/widgets", jsonString)
 resp = g('widget').createShowCreateId(projectIdInTest, json.toString())
 def conditionalHTMLWidgetId = resp.responseData.createId
 // snipet END
 */

====
listen http method
(tcp.dstport==8080 || tcp.srcport==8080) && http && http.request.method==POST

=======
// Has 12 against 100 failure

    /**
     * TASK Verify that lock property can be undo/redo, valid case.
     * TODO CURRENT TASK Verify, in the lock aspect, given a stack of transactions, 'undo' will always revoke the top one and pop
     * the stack, 'redo' would repeat the transaction revoked by the last 'undo'.
     * Multiple 'redo's would just put one transaction back to the stack.
     */
    //@Test(groups = ["feature"])
    @Test(groups = ["feature"], dataProvider = "DebugRepeatTimesProvider")
    //@DataProvider(name = "DebugRepeatTimesProvider")
    def void verifyLockUndoRedo() {
        def projectNameInTest = getMethodName(getCurrentTestNominal(Thread.currentThread().getStackTrace()).toString())
        listOfProjectsToRemove.add(projectNameInTest)
        def final String chapterNameInTest = "ChapterInTest"
        def resp,json,containerKey
        assertEquals((resp = g('project').create(projectNameInTest)).status, 201, "fail project create")
        def projectIdInTest = getProjectIdByNameFromResp(projectNameInTest, resp)

        assertEquals((g('chapter').create(projectIdInTest, (getJsonForDefaultChapter(chapterNameInTest)).toString())).status, 201, "fail chapter create")

        // Get contentId and chapterId of the chapter by name.
        assertTrue((resp = g('chapter').getAll(projectIdInTest)).data.chapters.size() >= 1, "There should be at least one chapter in system.")
        def contentIdInTest = getContentIdByChapterName(chapterNameInTest, resp)
        assertTrue(contentIdInTest != null && ((String) contentIdInTest).length() == UUIDStringLength, "Invalid content id.")
        def chapterIdInTest = getChapterIdByChapterName(chapterNameInTest, resp)
        assertTrue(chapterIdInTest != null && ((String) chapterIdInTest).length() == UUIDStringLength, "Invalid chapter id.")

        // PrintChapterURLForRestClient
        printChapterURLForRestClient (g('content'),projectIdInTest,contentIdInTest,chapterNameInTest)

        // Create batch1
        def batch1 = createNBatchWhiteListWidgets (1,g('common'),g('content'), g('widget'),'_',projectIdInTest, contentIdInTest, (containerKey= contentIdInTest) )
        assertEquals(batch1.size(), g('common').widgetTypeList().size(),"Widget batch create failed")

        // Lock batch1
        lockUnlockVerifyBatch (batch1,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"true"])

        // Undo assert locked equal false
        //g('UndoRedo').undo(projectIdInTest) //g('UndoRedo').redo(projectIdInTest)
        resp = g('UndoRedo').undo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch1, ["properties","locked"],resp,"false")

        // Redo assert locked equal true
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch1, ["properties","locked"],resp,"true")



        int stackDepth = 10;
        int stopPoint =(int )(Math.random()*(stackDepth-1)) + 1;
        Stack<String> opStack = new Stack<String>();
        for (int i = 0; i<stackDepth; i++) {
            if (((int) (Math.random() * 2)) == 1) {
                opStack.push("lock".toString());
            } else {
                opStack.push("unlock".toString());
            }
            // GROOVY UNFRIENDLY (not unfriendly, just not working) : opStack.push( (int )(Math.random()*2) == 1? "lock":"unlock");
        }
        Queue<String> opQueue = new LinkedList<String>();
        //opQueue.addAll(opStack); // WRONG
        Stack<String> localStack = new Stack<String>();
        localStack.addAll(opStack);
        while (!localStack.isEmpty()) {
            opQueue.add(localStack.pop());
        }
        println "opQueue: " + opQueue
        println "opStack: " + opStack

        // Assure the queue is the reverse of the stack
        //			while (!opQueue.isEmpty() && !opStack.isEmpty() ) {
        //				System.out.println(opQueue.poll().toString().equals(opStack.pop().toString()));
        //			}
        //			System.out.println("opQueue.isEmpty()="+opQueue.isEmpty()+"\topStack.isEmpty()"+opStack.isEmpty());

        // TODO Need statuses before lastOp
        // We know last locked is true
        Stack<String> lastStutasStack = new Stack<String>();
        lastStutasStack.push("true");
        while (!opQueue.isEmpty()) {
            String str = opQueue.poll();
            if (str.toString().equals("lock")) {
                // TODO Lock batch1
                lastStutasStack.push("true");
                lockUnlockVerifyBatch (batch1,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"true"])
            } else {
                // TODO unlock batch1
                lastStutasStack.push("false");
                lockUnlockVerifyBatch (batch1,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"false"])
            }
        }
        println "lastStutasStack: " + lastStutasStack

        lastStutasStack.pop()

        int p = 1;
        String lastOp = null;
        String lastStatus = null;
        while ( p++!=stopPoint) {
            // TODO undo
            resp = g('UndoRedo').undo(projectIdInTest)
            // TODO lastOp = pop stack
            lastOp = opStack.pop();
            lastStatus = lastStutasStack.pop()
        }

        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch1, ["properties","locked"],resp,lastStatus)
        /*
        if (lastOp.toString().equals("lock")) {
            // TODO Assert locked!=true
            verifyAttributes(batch1, ["properties","locked"],resp,"false")
        } else {
            // TODO Assert locked!=false
            verifyAttributes(batch1, ["properties","locked"],resp,"true")
        }
*/
        /*
        // TODO Redo
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        if (lastOp.toString().equals("lock")) {
            // TODO Assert locked=true
            verifyAttributes(batch1, ["properties","locked"],resp,"true")
        } else {
            // TODO Assert locked=false
            verifyAttributes(batch1, ["properties","locked"],resp,"false")
        }

        // TODO Redo, two or more redos equal one redo
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        if (lastOp.toString().equals("lock")) {
            // TODO Assert locked=true
            verifyAttributes(batch1, ["properties","locked"],resp,"true")
        } else {
            // TODO Assert locked=false
            verifyAttributes(batch1, ["properties","locked"],resp,"false")
        }
        */


        /*
        // Create batch2
        def batch2 = createNBatchWhiteListWidgets (1,g('common'),g('content'), g('widget'),'_',projectIdInTest, contentIdInTest, (containerKey= contentIdInTest) )
        assertEquals(batch2.size(), g('common').widgetTypeList().size(),"Widget batch create failed")

        // Lock batch2
        lockUnlockVerifyBatch (batch2,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"true"])

        // Unlock batch2
        lockUnlockVerifyBatch (batch2,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"false"])

        // Redo verify locked:false
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch2, ["properties","locked"],resp,"false")

        // TODO It fails here TBD
        //resp = g('UndoRedo').redo(projectIdInTest)
        //assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        */
        //verifyAttributes(batch2, ["properties","locked"],resp,"true")

        // Delete the project
        resp = g('project').delete(projectIdInTest)
        assertEquals(resp.status, 200, "fail delete project")
        listOfProjectsToRemove.remove(projectNameInTest.toString())
        log.warn("Congratulation, ${projectNameInTest} passed!")
    }

===============
Ignoring versioned files
$ git update-index --assume-unchanged irise.properties 

=====
MAC fn  up/down, page up/down ctrl-fn  left right file beg file end
Mac terminal linux console: ctrl-a home ctrl-e end
VIM ctrl-cmd-a ctrl-cmd-e  gg G 
=====
   /**
     * TODO TASK
     * TODO TASK CURRENT Verify that CHTML or its view can be locked, valid case.
     * TODO TASK Verify copying of chapter also copies the Lock property of widgets, valid case.
     * TODO TASK Verify that the locked widget can be associated to the actions, valid case.
     * TODO TASK Verify that you can lock localRef, valid case. localRef TBD
     * TODO TASK Verify that you cannot lock blacklist items ( menu, tables....), invalid case.
     * TODO TASK Verify creating actions from locked widget, valid case. Actions TBD?
     * TODO TASK
     * TODO TASK
     ﻿* TODO QUESTION At the service layer, do (x,y) change as per the new container?
     * TODO BUG TASK Verify that the locked widgets can be moved, valid case. To change (x,y) or to move to a different container.
     * TODO BUG TASK Verify that locking the container also locks its children, valid case. As per DOD-771.
     * TODO ISSUE see test function. TASK Verify that lock property can be undo/redo, valid case.
     * Undo redo definitions?
     */
=======
Ignore un-versioned files
git config --global core.excludesfile ~/.gitignore_global
vim ~/.gitignore_global
cat ~/.gitignore_global
/Users/zwang/Documents/irise/irise-service-test/irise.properties
.DS_Store
.DS_Store?

===================================

/**
 * TODO DONE Verify that locked widgets can be selected and deleted, valid case.
 * TODO DONE Put common, project, widget, chapter etc in a map: def synchronized getATool (String keyWord)
 * TODO DONE printChapterURLForRestClient (content,projectIdInTest,contentIdInTest,chapterNameInTest)
 * TODO DONE map key String case sensitive? Yes, "a" differs "A" as a key.
 * TODO DONE lock(), unlock()
 * def protected lockUnlockVerifyOneByOne (x,common,containerKey,widget,projectIdInTest,opVector)
 * def protected lockUnlockVerifyBatch (x,common,containerKey,widget,projectIdInTest, chapterIdInTest,opVector)
 * TODO DONE verifyNodeAttributeFromContentResp()
 * TODO DONE verifyNodeAttributeFromContentResp() //A set of of widgets
 * static def verifyAttributes(x, attributesVector,resp,expected)
 * TODO DONE Batch create whiteList widgets: static def createNBatchWhiteListWidgets (N,common,content, widget,tag,projectIdInTest, contentIdInTest, containerKey)
 * TODO DONE TASK Verify that the locked widgets can be cut/copy, valid case: cut/copied if locked still locked.
 * TODO DONE QUESTION // def itinerary = [] //class  println itinerary.getClass() java.util.ArrayList
 * TODO DONE QUESTION Returns false? if (visit[1].equals(chapterIdInTest))
 * println visit[1].getClass() //class org.codehaus.groovy.runtime.GStringImpl, it behaves differently from Java String class
 * TODO DONE QUESTION //?? batchWidgets[i] : new LinkedHashMap<String,?> box i to Integer or String, thus key 'i' not exist rather than retrieve element at position i
 * TODO DONE TASK Verify widgets can be dropped in locked container, valid case.
 * TODO DONE TASK Verify that lock property can be undo/redo, valid case.
 * TODO COMMIT POINT
 * TODO CONSIDERING Refactor getContentIdByChapterName, getChapterIdByChapterName
 * TODO CONSIDERING Test create CONDITIONAL_HTML
 * TODO QUESTION At the service layer, do (x,y) change as per the new container?
 * TODO BUG TASK Verify that the locked widgets can be moved, valid case. To change (x,y) or to move to a different container.
 * TODO BUG TASK Verify that locking the container also locks its children, valid case. As per DOD-771.
 * TODO ISSUE see test function. TASK Verify that lock property can be undo/redo, valid case.
 */
 


215  git remote set-url origin git@github.com:/iRise/irise-service-test
  218   git remote set-url origin git@github.com:wangzhikai/irise-service-test.git

======
Dev log of TestWidgetsLocking 20141014
    /**
     * TODO Done getLevelOneSubNotesIds(): static def getLevelOneSubNotesIds(content,projectId, chapterContentId,containerKey)
     * TODO Done test, groovy synchronized widgetsTypesCounters: synchronized def getAWidgetTypeCount (String type)
     * NOTE: if get method is synchronized, you don't have to use concurrent map or atomic stuff, but get() has to be synchronized
     * NOTE: this consideration is not necessary, since DC-wise widgets counter is not in the testing JVM instance. It tallers this program's cap, namely a distributed synchronized counter.
     * TODO Done QUESTION Java LinkedHashSet can replace a given node, without alternating the iteration sequence.
     * The answer is do not use set, use map instead.
     * TODO Done create standAloneWidgets[type_1, type_2]
     * [deprecated 20141014 BEG]
     * TODO Done Single widget create map:
     * 1. Required root attributes must be provided according to widgetCreateAttributes
     * NOTE: You cannot use addAll or putAll since you have to check required fields.
     * 2. Additional root attributes will be appended
     * 3. Required properties for create will use default
     * 4. Required properties can be changed than default
     * 5. Additional properties can be appended
     * 6. Handling conditional HTML
     * 7. Test create widgets
     * 8. Conditional_HTML create prop
     * 9. Use typesNamesPropsVector
     * [deprecated 20141014 END]
     * TODO Done Single widget create json : static def getSingleWidgetCreateJson(common,containerKey,rootCreateVector,propCreateVector)
     * TODO Done : static def getWidgetMap (common,containerKey,requiredRootAttributes, requiredProps, rootCreateVector,propCreateVector)
     * TODO Done Change set to map<IdAsString,?>
     * TODO Done Create batchWidgets[type_b_3, type_b_4]
     * TODO Done Refactor widgets creation : def getWidgetCreateElement (String tp,String tag,int n)
     * TODO Done Refactor assert resp
     * TODO Done Test java map addAll update all values, append keys new
     * TODO Done getWidgetMap
     * The case of widget creation
     * 1. This case is identified by function parameter widgetNodeInResp is an empty map  [:].
     * 2. Required root attributes are defined in requiredRootAttributes. All values must be provided by map newRootValues, or assert failure.
     * 3. After required root attributes are filled in, additional root attributes can be appended from newRootValues. AddAll should suffice.
     * 4. Required properties will be created from default, passed by parameter requiredProps
     * 5. Required properties will be updated by addAll of newPropValues map
     * The case of widget update
     * 1. This case identified by function parameter widgetNodeInResp is not an empty map.
     * 2.  Required root attributes are defined in requiredRootAttributes.
     * For each key, first try to get it from widgetNodeInResp. If found, the given value can be changed by newRootValues.
     * If not found, try to get it from newRootValues. If either fails, assert failure.
     * 3. After required root attributes are filled in, additional root attributes can be appended from newRootValues. AddAll should suffice.
     * 4. Required properties will be created from default, passed by parameter requiredProps
     * 5. Required properties will be update by values from widgetNodeInResp['properties']. Then addAll from newPropValues.
     * TODO Done Create stand-alone widget, update stand-alone widget
     * TODO Done Verify this method can also find a widgetNodeInResp : static def findAContainerInRespByUUID(node, UUID)
     * TODO Done Given a widget (a node in Resp), update from a new Resp, catch all new stuff, remove deprecated: just replace.
     * TODO Done Single widget update map
     * TODO Done Lock/unlock standAloneWidgets[type_1, type_2], two transactions
     * TODO Done Lock/unlock batchWidgets[type_b_1, type_b_2], one transaction
     * TODO Done Update widget(s) in batch
     * getBatchWidgetsUpdateMap(common,widgetsMap,containerKey,widgetRootUpdateVector,widgetPropUpdateVector)
     * getBatchWidgetsUpdateJson(common,widgetsMap,containerKey,widgetRootUpdateVector,widgetPropUpdateVector)
     * TODO Done Basic lock/unlock on white-list widgets, valid case.
     * TODO Done Verify that multiple widgets can be locked/unlocked at one go, valid case.
     * Lock/unlock batchWidgets[type_b_1, type_b_2], one transaction
     * TODO Done Lock lock assert unlock unlock assert
     * TODO Done
     * TODO Done
     * TODO COMMIT POINT, review and save to tech notes
     * TODO CONSIDERING Put common, project, widget, chapter etc in a map.
     * TODO CONSIDERING Refactor getContentIdByChapterName, getChapterIdByChapterName
     * TODO CONSIDERING Test create CONDITIONAL_HTML
     */
==== Basically, set is not preferably more advantageous than map. 
See LinkedHashSetReplaceTest

 git status | grep 'deleted' | sed 's/deleted://' | xargs -I{} git rm {}
====
#Intellij import suggestion
ALT ENTER


# regex not a character, regex not a literal
[^ \t]println
# regex uncommented println
^[ \t]*println

====HISTORY 20141010 ===
# the mvn bug just remove the ~/.m2
  314  vim ~/.m2/settings.xml 
  315  /Users/zwang/.m2/repository
20141029 Update
 507  mkdir dcmlui
  508  cd dcmlui
  514  git clone git@github.com:/mlui/suite.git
  515  cd suite
  517  git remote show origin
  523   git remote add mlui git@github.com:/mlui/suite.git
  524  git fetch mlui
  525  git checkout --track -b studio54_lite mlui/studio54_lite
  526  git pull
  527  git log
 533  git clone git@github.com:/mlui/dc.git
  534  cd dc
  535  git remote show origin
  536   git remote add mlui git@github.com:/mlui/dc.git
  537  git fetch mlui
  538   git checkout --track -b studio54_lite mlui/studio54_lite
mvn clean install -DskipTests -Dcobertura.skip
   542  git clone git@github.com:/iRise/dev-tools
  
  /Users/zwang/dcmlui/dev-tools/scripts/debug-dc.sh --war /Users/zwang/dcmlui/dc/muse-dc-web/target/muse-dc-web-9.0.5-SNAPSHOT.war --license-file /Users/zwang/dcmlui/dev-tools/scripts/irise.license --debug-port 5005 -Dcom.sun.management.jmxremote 1>>/Users/zwang/dcmlui/dclog.txt 2>> /Users/zwang/dcmlui/dclog.txt &
  499  tail -f /Users/zwang/dcmlui/dclog.txt

   70  cd ../dev-tools/scripts/
   76  git remote set-url origin git@github.com:irise/irise-service-test.git
  183  git add  src/test/groovy/com/irise/testng/featureTests/TestWidgetsGrouping.groovy
  201  cd ../dc
  202  git pull
  203  git remote show origin
  204  history | grep fetch
  217  git fetch mlui
  218  git rebase mlui/studio54_lite
  219  git log -5 --oneline
  220  mvn clean install -DskipTests -Dcobertura.skip
  221  cd ../dev-tools/
  222  git pull
  223  cd scripts/
  224  ls
  225  history | grep debug
  226  /Users/zwang/dcmlui/dev-tools/scripts/debug-dc.sh --war /Users/zwang/dcmlui/dc/muse-dc-web/target/muse-dc-web-9.0.5-SNAPSHOT.war --license-file /Users/zwang/dcmlui/dev-tools/scripts/irise.license --debug-port 5005 -Dcom.sun.management.jmxremote 1>>/Users/zwang/dcmlui/dclog.txt 2>> /Users/zwang/dcmlui/dclog.txt &
  227  tail -f /Users/zwang/dcmlui/dclog.txt 
  228  fg
  229  fg
  313  ls /Users/zwang/.m2/repository
  
   git clone git@github.com:/mlui/suite.git
  324  git checkout --track -b studio54_lite mlui/studio54_lite
  325  git fetch mlui
  326   git remote add mlui git@github.com:/mlui/suite.git
  327  git fetch mlui
  328  git checkout --track -b studio54_lite mlui/studio54_lite
  329  mvn clean install
  330  cd ~/Documents/irise/irise-service-test


  343  git push
  344  ifconfig
  345  vim /etc/hosts
  346  sudo vim /etc/hosts
  347  ping irises-mbp-6
  348  ping irlaeng07.ircorp.com
  349  ifconfig
  350  ping irlaeng07


  355  sudo vim /etc/hosts
  356  ping ie11three

  392  mvn clean install -DskipTests -Dcobertura.skip 
