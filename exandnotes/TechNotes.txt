==== Sed Command in Unix and Linux Examples 
http://www.folkstalk.com/2012/01/sed-command-in-unix-examples.html
1. Replacing or substituting string
sed 's/unix/linux/' file.txt
2. Replacing the nth occurrence of a pattern in a line.
sed 's/unix/linux/2' file.txt
3. Replacing all the occurrence of the pattern in a line.
sed 's/unix/linux/g' file.txt
4. Replacing from nth occurrence to all occurrences in a line.
sed 's/unix/linux/3g' file.txt
5. Changing the slash (/) delimiter
:~ zwang$ sed 's_unix_latinx_' file.txt
latinx is great os. unix is opensource. unix is free os.
learn operating system.
latinxlinux which one you choose.
:~ zwang$ cat file.txt 
unix is great os. unix is opensource. unix is free os.
learn operating system.
unixlinux which one you choose.
6. Using & as the matched string
sed 's/unix/{&}/' file.txt
7. Using \1,\2 and so on to \9
The parenthesis needs to be escaped with the backslash character. Another example is if you want to switch the words "unixlinux" as "linuxunix", the sed command is

>sed 's/\(unix\)\(linux\)/\2\1/' file.txt
unix is great os. unix is opensource. unix is free os.
learn operating system.
linuxunix which one you choose.
8. Duplicating the replaced line with /p flag
sed 's/unix/linux/p' file.txt
11. Replacing string on a specific line number.
sed '3 s/unix/linux/' file.txt
12. Replacing string on a range of lines.
>sed '1,3 s/unix/linux/' file.txt
14. Deleting lines.

You can delete the lines a file by specifying the line number or a range or numbers.

>sed '2 d' file.txt
>sed '5,$ d' file.txt
20. Transform like tr command

The sed command can be used to convert the lower case letters to upper case letters by using the transform "y" option.

>sed 'y/ul/UL/' file.txt
Unix is great os. Unix is opensoUrce. Unix is free os.
Learn operating system.
UnixLinUx which one yoU choose.


=====
build.gradle: jvmArgs += [ "-XX:MaxPermSize=256m" ] -- 20141219
-XX:ParallelCMSThreads=<n>
The following are far better not.
  jvmArgs += [ "-XX:PermSize=512m" ]
   jvmArgs += [ "-XX:MaxPermSize=1024m" ]
   jvmArgs += [ "-XX:ParallelCMSThreads=2" ]
Otherwise failure at 82M perm gen is almost deterministic.
Remaining tests probably skipped.
   
=====
Almost the same as Tibergem said, one hundred lines one bug.
=====
http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html


Java Garbage Collection Basics
Java Virtual Machine

The Java Virtual Machine (JVM) is an abstract computing machine. The JVM is a program that looks like a machine to the programs written to execute in it.

The heap is where your object data is stored. This area is then managed by the garbage collector selected at startup. 

Throughput

Throughput focuses on maximizing the amount of work by an application in a specific period of time. Examples of how throughput might be measured include:

- The number of transactions completed in a given time.
- The number of jobs that a batch program can complete in an hour.
- The number of database queries that can be completed in an hour.

GC
1. Marking 2. Deletion with Compacting 

The information learned from the object allocation behavior can be used to enhance the performance of the JVM. Therefore, the heap is broken up into smaller parts or generations. The heap parts are: Young Generation, Old or Tenured Generation, and Permanent Generation

Stop the World Event - All minor garbage collections are "Stop the World" events. This means that all application threads are stopped until the operation completes. Minor garbage collections are always Stop the World events.

Only young generation is FILLED UP. Stop WORLD happens. 
It could not be login server with 20G even 48G. Only the app servers do the linguistic stuff qualify.
SCM.
1. First, any new objects are allocated to the eden space. Both survivor spaces start out empty.
2. When the eden space fills up, a minor garbage collection is triggered.
3. Referenced objects are moved to the first survivor space. Unreferenced objects are deleted when the eden space is cleared.
4. At the next minor GC, the same thing happens for the eden space. Unreferenced objects are deleted and referenced objects are moved to a survivor space. However, in this case, they are moved to the second survivor space (S1). In addition, objects from the last minor GC on the first survivor space (S0) have their age incremented and get moved to S1. Once all surviving objects have been moved to S1, both S0 and eden are cleared. Notice we now have differently aged object in the survivor space.
5. At the next minor GC, the same process repeats. However this time the survivor spaces switch. Referenced objects are moved to S0. Surviving objects are aged. Eden and S1 are cleared.
6. This slide demonstrates promotion. After a minor GC, when aged objects reach a certain age threshold (8 in this example) they are promoted from young generation to old generation.
7.As minor GCs continue to occure objects will continue to be promoted to the old generation space.

8. So that pretty much covers the entire process with the young generation. Eventually, a major GC will be performed on the old generation which cleans up and compacts that space.

Major garbage collection are also Stop the World events. Often a major collection is much slower because it involves all live objects. So for Responsive applications, major garbage collections should be minimized. Also note, that the length of the Stop the World event for a major garbage collection is affected by the kind of garbage collector that is used for the old generation space.
 java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar
 
 jvisualvm

Command Line Switches

To enable the Serial Collector use:
-XX:+UseSerialGC

Usage Cases

The Parallel collector is also called a throughput collector. Since it can use multilple CPUs to speed up application throughput. This collector should be used when a lot of work need to be done and long pauses are acceptable. For example, batch processing like printing reports or bills or performing a large number of database queries.
-XX:+UseParallelGC

-XX:+UseParallelOldGC
The Concurrent Mark Sweep (CMS) Collector

The Concurrent Mark Sweep (CMS) collector (also referred to as the concurrent low pause collector) collects the tenured generation. It attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. Normally the concurrent low pause collector does not copy or compact the live objects. A garbage collection is done without moving the live objects. If fragmentation becomes a problem, allocate a larger heap.
To enable the CMS Collector use:
-XX:+UseConcMarkSweepGC
and to set the number of threads use:
-XX:ParallelCMSThreads=<n>

The G1 Garbage Collector

The Garbage First or G1 garbage collector is available in Java 7 and is designed to be the long term replacement for the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector that has quite a different layout from the other garbage collectors described previously. However, detailed discussion is beyond the scope of this OBE.
Command Line Switches

To enable the G1 Collector use:
-XX:+UseG1GC


========================
Gradle/Groovy Automated Test
* Functional Test Rest Endpoints
- no performance
- no concurrent testing
* Creating/monitoring Threads
* Given, When, Then paradigm
* Test cases
* About CRUD (chapter, content, widget types etc)
* Do not use iDoc, S54 supported
* Leverage exist API or fix it


====================
HttpResponseDecorator resp

=======================
Groovy returns 'true'
        def map1 = ['g':'k']
        def map2 = ['w':'d']

        if ( map1.get('c') == map2.get('d')) {
            log.info "true"
        } else {
            log.info "false"
        }

=====================
In programming languages, a closure (also lexical closure or function closure) is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.[

http://en.wikipedia.org/wiki/Closure_%28computer_programming%29

=======================

TODO DONE TASK 1. Create a switchview with target 'chtmlId:Next' from button 2. Cut button 3. Paste button in same chapter. Valid case.

/**
 * Created by zwang on 11/3/14.
 * TODO DONE TASK Create a switch view action with target = <chtmlId>:Next. Read switch view. Valid case.
 * TODO DONE TASK Create a switch view action with target = <chtmlId>:Previous. Read switch view. Valid case.
 * TODO DONE TASK Create a switch view action with target = <chtmlId>:Initial. Read switch view. Valid case.
 * TODO DONE TASK Create a switch view action with target = <chtmlId>:Hide. Read switch view. Valid case.
 * TODO DONE TASK Create a switch view action with target = <chtmlId>:Default. Read switch view. Valid case.
 * TODO DONE TASK Create a switch view action with target = viewId. Read switch view. Valid case.
 * TODO DONE TASK Create a switch view with multiple chtml targets having multiple meta view values: targets=[<chtml1>:Next, <chtml2>:Previous, <chtml3>:Initial, <chtml4>:Default,<chtml5>:Hide]. Valid case.
 * TODO DONE TASK Create switchView with invalid targetId, for example: 1. button on page 2. <viewId>:Next. Invalid case.
 * TODO DONE TASK Create a switch view with sourceId = pageContentId, masterId, cloudContentId, TemplateContentId. Control case.
 * TODO DONE TASK Create switchviews with entire permutation(QA: should be combinations of effects' properties) of properties. Valid case.
 * TODO DONE TASK Create switchView with invalid properties: delay, duration, direction, transition type. Invalid case.
 * TODO DONE TASK Read from iDoc (include chaining switchView1 -> switchView2 -> switchView3). Valid case.
 * TODO DONE TASK Read from iDoc with Empty View as target. Control case.
 * TODO DONE TASK Update targetIds with valid targets 1. Meta View (Next, Previous, etc) 2. ViewId 3. Empty targets. Valid case.
 * TODO DONE TASK Update targetIds with invalid targets 1. button on page 2.chtml. Invalid case.
 * TODO DONE TASK Update properties: delay, duration, direction, transition type. Valid case.
 * TODO DONE TASK Update invalid properties. Invalid case.
 * TODO DONE TASK Delete a trigger with 1 action sequence containing 3 switchViews. Valid case.
 * TODO DONE TASK Delete each switchView iteratively from a sequence. Valid case.
 * TODO DONE TASK Read a chapter with meta views and verify isSupported = true. Valid case.
     * TODO DONE TASK Read a chapter where button has rule set to 'based on data' and verify isSupported=false. Invalid case.
     * TODO DONE At the same time, testing creating two projects by loading iDocs, and handling them properly during test and after test. In fact, we can use vectors to handle as many as it permits.
     * TODO Check delay/durations were invariant.
 
 *
 *

 * TODO QUESTION remove from test, create longrun task?
 *
 * TODO CHECK ALL CLONE()s // BAD: toUpdateTriggerMap = preUpdateTriggerMap.clone() // you can not use clone, it did not do full deep copy. ['sequences'][0]['actions'][0]['properties'] is reference copy.
 * TODO CHECK All assignment = without deep copy.

 * TODO DONE Update check new values bounced back ( from resp)
 * TODO DONE Remove private def synchronized getATool(String keyWord)
 * TODO DONE ?:      Ternary (shorthand for if-then-else statement) -- http://groovy.codehaus.org/Operators
 Safe Navigation Operator (?.)
 The Safe Navigation operator is used to avoid a NullPointerException. Typically when you have a reference to an object you might need to verify that it is not null before accessing methods or properties of the object. To avoid this, the safe navigation operator will simply return null instead of throwing an exception, like so:
 def user = User.find( "admin" )           //this might be null if 'admin' does not exist
 def streetName = user?.address?.street    //streetName will be null if user or user.address is null - no NPE thrown

 Regular Expression Operators
 find (=~)
 match (==~)
 * TODO DONE Refactor to testOneMetaViewWithRandomFactors
 * TODO DONE DEBUG CHTML children background color not shown
 * TODO DONE Color CHTML, test with simulation,"backgroundColor": "#0000ff" etc
 * TODO DONE Question, chtml is created if only add children: looks so.
 * TODO DONE QUESTION, widget create name is required field, inconsistency?
 *     //﻿{"type":"SECTION","containerKey":"9e4ec47c3f1d472da8874a73d4b8b556","properties":{"defaultBranchView":"true"},"sourceWidgetId":"723cc277795e498f9baf834ccc88a7f1","sourceProjectId":"906d175249e649bebe105de65e586236"}*     Developer: Here the ‘name’ field is NOT required because we are providing ‘sourceWidgetId’. The ‘name' field is mandatory only if ’sourceWidgetId’ is not present in request body.
 * TODO DONE CHECK all vaild matrices and invalid matrices call hierarchy: constructNotValidSwitchViewsMatrix,constructValidSwitchViewsMatrix
 * TODO DONE cartesian product. java.util.Collection.metaClass.cartesianProduct, no such a thing in Java, write one myself.
 * TODO DONE Fxied 20141119 DELAY >=61 issue
 * createSwitchViewWithInvalidProperties()
 verify with legacy studio
 15:55:24 INFO  Utilities - 201	 Illegal prop [Previous, TRANS_TYPE_NONE, null, null, 61]
 discuss with developer:
 [Default, TRANS_TYPE_NONE, null, null, 61] is OK? Fxied 20141119


 * TODO CONSIDERING Position ADT should be as per page
 * TODO REFACTOR TASK Verify user can read all supported views with effects/delays
 * TODO DONE REFACTOR DELETED merged to createSwitchViewsWithEntirePermutationOfProperties. TASK Verify user can create all supported views with effects/delays
 * TODO REFACTOR TASK Verify user can delete views in Action type: switch view
 * TODO REFACTOR TASK Verify user can update all views in Action type: switch view
 * TODO QUESTION, sequence:actions 1:+; actions:effect 1:1; action:effects 1:+?; action:target 1:*.
 * REFACTOR: createSwitchViewWithViewTargets createSwitchViewWithViewTargets



 *
 * TODO Refactor as per code review session 20141107
 *      TODO All resp assert plus resp.responseData["failures"]
 *      TODO Remove any functions not called in this class
 *      TODO
 * gist
 * - Extension evasion
 * - Functional program
 * - Cut test body short
 * - Utility class
 * - Apply to grouping, chapter reorder, locking, switch views.
 * TODO Create/merge to a Utility class
 *
 *
 * TODO Proof read + GIVEN, WHEN, THEN
 *
 *
 * TODO DONE Question: the direction will be same as legacy studio, or as per rest test observation. Where are they defined?
 * TODO DONE MetaViewsOfSwitchViews [Previous,Next,Default,Initial,Hide][Invalid]
 * TODO DONE Refer TestAction for
 * TODO OUT OF QUESTION API differs from automation Trigger class
 * TODO DONE API reference delete after tasks
 * TODO OUT Considering automate Go to editor, align buttons, (save idoc as SwitchViews02.idoc)
 * TODO OUT Question should delay >= duration?
 * TODO OUT Interesting, CHTML view can be at a different position than the section as the source.
 *
 *
 * TODO CONSIDERING Compare fully recursively two nodes.
 * There should be a deepCompare with the floating point numbers nightmare, string locales, encoding, line feed, carriage, escape sequence, what else?
 */

==============================================
    //@Test(groups = ["feature"]) // 
    protected def void strictTypeCast () {
        def someArray = [1,3,2,4]
        //def delay = (int) (Math.random() * (  + 1))
        for (int i = 0; i < 100; i++) {
            int c =  (int) (Math.random() * someArray.size())
          log.info  c
        }
        for (int i = 0; i < 100; i++) {

            int c =  (int) Math.random() * someArray.size()
            log.info  c
        }
        // Both ways achieve the same effect, but the first one is safer.
     }
=============================================== 

    /**
     * @param list1 : LHS of X
     * @param list2 : RHS of X
     * @return  cartesian product of two collections
     */
    public static def getListListCartesian (List list1, List list2) {
        List result = new LinkedList()
        int lastRowSize = -1
        for (def e1: list1) {
            for (def e2: list2 ){
                def currentRow = new LinkedList()
                // e1 instance of List else
                if (e1 instanceof List) {
                    for (def e:e1 ) {
                        currentRow.add(e)
                    }
                } else {
                    currentRow.add(e1)
                }

                // e2 instance of List else
                if (e2 instanceof List) {
                    for (def e:e2 ) {
                        currentRow.add(e)
                    }
                } else {
                    currentRow.add(e2)
                }

                if (lastRowSize != -1) {
                    assertEquals(lastRowSize,currentRow.size(),"Matrices dimensions not match.")
                }
                lastRowSize = currentRow.size()
                result.add(currentRow)
            }
        }
        result
    }

===================================
    /**
     * @param resp
     * @return chaptersHolder [
     uniqueName:[uniqueName,chapterId,contentId]
     duplicateName:[
     [chapterId1:[duplicateName,chapterId1,contentId1]
     [chapterId2:[duplicateName,chapterId2,contentId2]
     ]
     ]
     */
    static def getChaptersHolderFromResp (resp) {
        Map chaptersHolder =[:]
        for (def c: resp.data.chapters) {
            if (chaptersHolder.containsKey(c['name'])) {
                def value = chaptersHolder.get(c['name']) // value is map<id,[name,chpId,contId]>
                if (value instanceof List) {
                    def vMap = [:]
                    // put back value
                    vMap.put(value[1],[value[0],value[1],value[2]])
                    // add c
                    vMap.put(c['id'],[c['name'],c['id'],c["content"]["id"]])
                    // put vMap
                    chaptersHolder.put(value[0],vMap)
                } else { // value is a map
                    value.put(c['id'],[c['name'],c['id'],c["content"]["id"]])
                }
            } else {
                chaptersHolder.put(c['name'],[c['name'],c['id'],c["content"]["id"]])
            }
        }
        chaptersHolder
    }
=================

`WireSHARK TCP , find packet Find by String , Packet bytes,
filter json, right click json, copy, bytes, printable 
================
build mozilla FF 
./mach build 

=========  
JMC parameters

-XX:+UnlockCommercialFeatures -XX:+FlightRecorder
=============================================
/**
 * Created by zwang on 10/24/14.
 *
 * Notes:
 *
 * - Disambiguation of 'chapters reorder'.
 *  Legacy studio behavior, given a single chapter project. Folder structure [F1  [F2  C1a]]. | is move destination.
 *  [F1 [F2 | C1]] leads to [F1 [F2 C1]] NO CHANGE
 *  [F1 | [F2 C1]] leads to [F1 C1 [F2]]
 *  |[F1 [F2 C1]] leads to C1 [F1 [F2]]
 *  [F1 [F2 C1|]|]| leads to [F1 [F2 C1]] NO CHANGE
 *  So in this test file, we only verify chapter order against chapter, not order against folder, unless DC provides 'chapter folder' API.
 *  Another example, when try to move C1 after C2, in structure C1 [F1 [F2 C2]] [F3 [F4]].
 *  So for any destination, after moving.
 *  - if there is a 'next' chapter, we take the same folder as the next.
 *  - if there is no 'next', any folder will suffice, given the moved chapter is the last chapter.
 *  In tests, we simply use the goal chapter's folder for convenience.
 *
 * - Middle: we consider it is the element at size() div 2 + 1. Eg. five chapters, the middle is No.3. Four, we get No.3.
 *   Two, we get No.2. One, we get No.1.
 *
 */
/**
 * TODO DONE Map getAllChapters
 * TODO DONE deleteAllChapters
 * TODO DONE print chapters [name,id] other than [id] only to assure the initial order is as per order created. Need peep UI.
 * TODO DONE QUESTION, will valueSet() keep the order, Map<K,V> does not have valueSet(), has values() returns instanceof List<V>.
 * TODO DONE TASK Move 1st chapter to the last position
 * TODO DONE Change all Queues to LinkedList
 * TODO DONE TASK Move the last chapter to the top position.
 * TODO DONE Move middle chapter to be last
 * TODO DONE Move middle chapter to be first. Valid case.
 * TODO DONE QUESTION Disambiguation of 'chapters reorder'.
 * Legacy studio behavior, given a single chapter project. Folder structure [F1  [F2  C1]]. | is move destination.
 * [F1 [F2 | C1]] leads to [F1 [F2 C1]] NO CHANGE
 * [F1 | [F2 C1]] leads to [F1 C1 [F2]]
 * |[F1 [F2 C1]] leads to C1 [F1 [F2]]
 * [F1 [F2 C1|]|]| leads to [F1 [F2 C1]] NO CHANGE
 * So in this test file, we only verify chapter order against chapter, not order against folder, unless DC provides 'chapter folder' API.
 * Another example, when try to move C1 after C2, in structure C1 [F1 [F2 C2]] [F3 [F4]].
 * So for any destination, after moving.
 * - if there is a 'next' chapter, we take the same folder as the next.
 * - if there is no 'next', any folder will suffice, given the moved chapter is the last chapter.
 * TODO DONE Refactor existing tests according to new move constraint, discussed as the above paragraph.
 * TODO DONE Coding style according to code review meeting:
 * 1. Create separate utility class.
 * 2. Follow given/when/then concept.
 * 3. Use “static” keyword wisely.
 * 4. Make sure one test does only ONE thing.
 * 5. Avoid extension of classes.
 * 6. Extra line between two functions.
 * TODO DONE Move the first chapter down bellow a chapter that is in a folder. Valid case.
 * TODO DONE Move last chapter that is in folder to the very top. Valid case.
 * TODO DONE Move middle chapter that is in folder to the very top. Valid case.
 * TODO DONE Re-order pages that are in folders. Example: Page1, Page2, Page3 are in folders. Move Page3 after Page1. Valid case.
 * TODO DONE Move a page between pages in a folder. Valid case.
 * TODO DONE Re-oder chapters in a project that contains multilevel empty folders. Valid case.
 * TODO DONE Do re-order with undo/redo combination. Valid case.
 * TODO DONE Validation error should be thrown for invalid chapterId and invalid folderId. Invalid case.
 * TODO DONE Try to change chapter name. Expected: validation error. Invalid case.
 * TODO DONE Use complex idoc with lot of chapters/folders.
 *
 *
 *
 * TODO proof read comments, clean up.
 *
 *
 *
 * TODO CONSIDERING Stress test MAX number of regular pages in a project in localhost.
 * TODO CONSIDERING Create a folder using REST API other than legacy studio? Possible?
 * TODO CONSIDERING Make log4j run properly in IntelliJ console test.
 * TODO QUESTION, Java pass 1.func(Type var )const, 2.func (Type const&  var), 3.func( Type & const var ), 4.func(const Type var ) equivalences?
 * TODO QUESTION, It looks like testNG did not join the test thread, or handle the 1 and 2 file descriptors properly (flush all the buffers, before exit). Is this the reason we miss some console output (System.out.print) in Intellij, or the finger should point to Intellij?
 */
 
 20141031

================================
# touch hyphen
touch '-'

================================

//TODO DONE unsupportedTests this file's package is wrong, shoule be scenarioTests, so we can re-use its prop_t
//import com.irise.testng.unsupportedTests.CreateActionTest
//And it may always good to put constants as static final or load from a property files
//import com.irise.testng.scenarioTests.CreateActionTest
/**
 * Created by zwang on 10/10/14.
 */
/**
 * TODO DONE Change all .equals() to .toString().equals()
 * TODO DONE INFO Widget CONDITIONAL_HTML cannot be created without children
 * TODO DONE QUESTION println ''.getClass() class java.lang.String
 * TODO DONE INFO how cHTML is created
 // Create conditional HTML, add buttons to it
 json {
    type "CONDITIONAL_HTML"
    children([
        { sourceWidgetId childrenWidgetsSet[0]["id"] },
        { id childrenWidgetsSet[0]["id"] }
    ])
 }
 println prettyPrint(json.toString())
 {
    "type": "CONDITIONAL_HTML",
    "children": [
        {   "sourceWidgetId": "10622ed5f6e84d408fc78324403266b6"},
        {   "id": "10622ed5f6e84d408fc78324403266b6"    }
    ]
 }
 resp = widget.createShowCreateId(projectIdInTest, json.toString())
 def conditionalHTMLWidgetId = resp.responseData.createId
 NOTE: the two children look must be of the same type. QUESTION ? !
 * TODO DONE if CONDITIONAL_HTML remove containerKey QUESTION ? !
 * static def getWidgetMap (containerKey,widgetNodeInResp,requiredRootAttributes, requiredProps, newRootValues,newPropValues) {
 * ﻿TODO DONE TASK CURRENT Verify that CHTML or its view can be locked, valid case.
 * TODO DONE TASK Verify, in the lock aspect, given a stack of transactions, 'undo' will always revoke the top one and pop the stack.  Redo has its stack of 'undos', as per discussion.
 ﻿* TODO DONE TASK Verify copying of chapter also copies the Lock property of widgets, valid case.
 * TODO DONE Find nodes by name keyword in content resp. findNodesByNameKeywordToMap (node, keyword)
 * TODO DONE TASK Verify that the locked widget can be associated to the actions, valid case.
 *       for (def chap : resp.data.chapters) {
 //TODO DONE Test isTreeBranchValid (propVector, node)
 for (def chap : resp.data.chapters)
     println "isTreeBranchValid (['content','id'], node) = "+isTreeBranchValid (["content","id"], chap)
     println "isTreeBranchValid (['ctent','id'], node) = "+isTreeBranchValid (['ctent','id'], chap)
     println "isTreeBranchValid (['content','iid'], node) = "+isTreeBranchValid (['content','iid'], chap)
     println "isTreeBranchValid ([''], node) = "+isTreeBranchValid ([''], chap)
 OUTPUT
 isTreeBranchValid (['content','id'], node) = true
 isTreeBranchValid (['ctent','id'], node) = false
 isTreeBranchValid (['content','iid'], node) = false
 isTreeBranchValid ([''], node) = false
 //TODO DONE Test static def prettyRespData (resp)
 * TODO DONE TASK Verify creating actions from locked widget, valid case. Actions TBD?
 * TODO DONE INFO resp instanceof roovyx.net.http.HttpResponseDecorator
 //TODO DONE QUESTION What indicates a widget is blacklisted? The answer if a chapter not supported, its widgets if any is 'blacklisted'.
 //TODO DONE QUESTION Why Some can be locked some not? As above. So the UI layer is supposed to fence off the illegal request.
 * TODO DONE TASK Verify that you cannot lock blacklist items ( menu, tables....), invalid case.
 * TODO DONE USE the required properties to create chapter, page, master etc.
 * TODO DONE TASK Verify that you can lock localRef, valid case. localRef TBD
 *
 *
 *
 * TODO TASK Verify that the locked widget can be associated to the actions, valid case.  Reopen to use trigger API.
 * TODO TASK Clean up this file as per stand-up discussion.
 *
 // TODO QUESTION CAN NOT DROP  master1(master) to page1, don't have to commit this part.
 //        // Failed
 //        sourceChapterId = chapterIds.get('master1')
 //        targetContentId = contentIds.get('page1')
 //        resp = g('chapter').dropMasterOnPage(projectIdInTest, chapterIds.get('page1'),new JsonBuilder([sourceId:sourceChapterId,targetId:targetContentId,x:200,y:200]).toString())
 //        assertEquals(resp.status, 201, "Failed to drop Master on Page " + resp.responseData["failures"])
 // TODO QUESTION NOTE local_ref at this phase 20141023 is not whitelisted
 ﻿* TODO QUESTION At the service layer, do (x,y) change as per the new container?
 * TODO QUESTION Unlock CHTML did not unlock children
 * Gist:
 * 1. Locked will be a required property
 * 2. For container's children, lock property is examined in UI aspect.
 * TODO BUG TASK Verify that the locked widgets can be moved, valid case. To change (x,y) or to move to a different container.
 *
 // TODO DONE his snipet works, the chtml would contain two same type element as c (batch1[0])
 def c=[]
 int i =0
 for (def v : batch1) {
 c += [sourceWidgetId:v.getKey()]
 c += [id:v.getKey()]
 //            json {
 //                type "CONDITIONAL_HTML"
 //                name "some name"
 //                children([
 //                        { sourceWidgetId v.getKey() },
 //                        { id v.getKey() }
 //                ])
 //            }
 if (++i ==1)
 break;

 }
 def m = [:]
 m['type'] = "CONDITIONAL_HTML"
 m['name'] = "C1"
 m['children'] = c
 m['properties'] = ["locked": "false", "z": "7", "rules": "None", "y": "10", "x": "10"]
 json = new JsonBuilder(m)
 println prettyPrint(json.toString())
 //                {
 //                    "type": "CONDITIONAL_HTML",
 //                    "name": "C1",
 //                    "children": [
 //                        {
 //                            "sourceWidgetId": "85855789400643c6ba77765984d0e2b3"
 //                        },
 //                        {
 //                            "id": "85855789400643c6ba77765984d0e2b3"
 //                        }
 //                ],
 //                    "properties": {
 //                    "locked": "false",
 //                    "z": "7",
 //                    "rules": "None",
 //                    "y": "10",
 //                    "x": "10"
 //                }
 //                }
 //POST rest.post("projects/${projectId}/widgets", jsonString)
 resp = g('widget').createShowCreateId(projectIdInTest, json.toString())
 def conditionalHTMLWidgetId = resp.responseData.createId
 // snipet END
 */

====
listen http method
(tcp.dstport==8080 || tcp.srcport==8080) && http && http.request.method==POST

=======
// Has 12 against 100 failure

    /**
     * @param list1 : LHS of X
     * @param list2 : RHS of X
     * @return  cartesian product of two collections
     */
    public static def getListListCartesian (List list1, List list2) {
        List result = new LinkedList()
        int lastRowSize = -1
        for (def e1: list1) {
            for (def e2: list2 ){
                def currentRow = new LinkedList()
                // e1 instance of List else
                if (e1 instanceof List) {
                    for (def e:e1 ) {
                        currentRow.add(e)
                    }
                } else {
                    currentRow.add(e1)
                }

                // e2 instance of List else
                if (e2 instanceof List) {
                    for (def e:e2 ) {
                        currentRow.add(e)
                    }
                } else {
                    currentRow.add(e2)
                }

                if (lastRowSize != -1) {
                    assertEquals(lastRowSize,currentRow.size(),"Matrices dimensions not match.")
                }
                lastRowSize = currentRow.size()
                result.add(currentRow)
            }
        }
        result
    }

    /**
     * TASK Verify that lock property can be undo/redo, valid case.
     * TODO CURRENT TASK Verify, in the lock aspect, given a stack of transactions, 'undo' will always revoke the top one and pop
     * the stack, 'redo' would repeat the transaction revoked by the last 'undo'.
     * Multiple 'redo's would just put one transaction back to the stack.
     */
    //@Test(groups = ["feature"])
    @Test(groups = ["feature"], dataProvider = "DebugRepeatTimesProvider")
    //@DataProvider(name = "DebugRepeatTimesProvider")
    def void verifyLockUndoRedo() {
        def projectNameInTest = getMethodName(getCurrentTestNominal(Thread.currentThread().getStackTrace()).toString())
        listOfProjectsToRemove.add(projectNameInTest)
        def final String chapterNameInTest = "ChapterInTest"
        def resp,json,containerKey
        assertEquals((resp = g('project').create(projectNameInTest)).status, 201, "fail project create")
        def projectIdInTest = getProjectIdByNameFromResp(projectNameInTest, resp)

        assertEquals((g('chapter').create(projectIdInTest, (getJsonForDefaultChapter(chapterNameInTest)).toString())).status, 201, "fail chapter create")

        // Get contentId and chapterId of the chapter by name.
        assertTrue((resp = g('chapter').getAll(projectIdInTest)).data.chapters.size() >= 1, "There should be at least one chapter in system.")
        def contentIdInTest = getContentIdByChapterName(chapterNameInTest, resp)
        assertTrue(contentIdInTest != null && ((String) contentIdInTest).length() == UUIDStringLength, "Invalid content id.")
        def chapterIdInTest = getChapterIdByChapterName(chapterNameInTest, resp)
        assertTrue(chapterIdInTest != null && ((String) chapterIdInTest).length() == UUIDStringLength, "Invalid chapter id.")

        // PrintChapterURLForRestClient
        printChapterURLForRestClient (g('content'),projectIdInTest,contentIdInTest,chapterNameInTest)

        // Create batch1
        def batch1 = createNBatchWhiteListWidgets (1,g('common'),g('content'), g('widget'),'_',projectIdInTest, contentIdInTest, (containerKey= contentIdInTest) )
        assertEquals(batch1.size(), g('common').widgetTypeList().size(),"Widget batch create failed")

        // Lock batch1
        lockUnlockVerifyBatch (batch1,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"true"])

        // Undo assert locked equal false
        //g('UndoRedo').undo(projectIdInTest) //g('UndoRedo').redo(projectIdInTest)
        resp = g('UndoRedo').undo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch1, ["properties","locked"],resp,"false")

        // Redo assert locked equal true
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch1, ["properties","locked"],resp,"true")



        int stackDepth = 10;
        int stopPoint =(int )(Math.random()*(stackDepth-1)) + 1;
        Stack<String> opStack = new Stack<String>();
        for (int i = 0; i<stackDepth; i++) {
            if (((int) (Math.random() * 2)) == 1) {
                opStack.push("lock".toString());
            } else {
                opStack.push("unlock".toString());
            }
            // GROOVY UNFRIENDLY (not unfriendly, just not working) : opStack.push( (int )(Math.random()*2) == 1? "lock":"unlock");
        }
        Queue<String> opQueue = new LinkedList<String>();
        //opQueue.addAll(opStack); // WRONG
        Stack<String> localStack = new Stack<String>();
        localStack.addAll(opStack);
        while (!localStack.isEmpty()) {
            opQueue.add(localStack.pop());
        }
        println "opQueue: " + opQueue
        println "opStack: " + opStack

        // Assure the queue is the reverse of the stack
        //			while (!opQueue.isEmpty() && !opStack.isEmpty() ) {
        //				System.out.println(opQueue.poll().toString().equals(opStack.pop().toString()));
        //			}
        //			System.out.println("opQueue.isEmpty()="+opQueue.isEmpty()+"\topStack.isEmpty()"+opStack.isEmpty());

        // TODO Need statuses before lastOp
        // We know last locked is true
        Stack<String> lastStutasStack = new Stack<String>();
        lastStutasStack.push("true");
        while (!opQueue.isEmpty()) {
            String str = opQueue.poll();
            if (str.toString().equals("lock")) {
                // TODO Lock batch1
                lastStutasStack.push("true");
                lockUnlockVerifyBatch (batch1,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"true"])
            } else {
                // TODO unlock batch1
                lastStutasStack.push("false");
                lockUnlockVerifyBatch (batch1,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"false"])
            }
        }
        println "lastStutasStack: " + lastStutasStack

        lastStutasStack.pop()

        int p = 1;
        String lastOp = null;
        String lastStatus = null;
        while ( p++!=stopPoint) {
            // TODO undo
            resp = g('UndoRedo').undo(projectIdInTest)
            // TODO lastOp = pop stack
            lastOp = opStack.pop();
            lastStatus = lastStutasStack.pop()
        }

        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch1, ["properties","locked"],resp,lastStatus)
        /*
        if (lastOp.toString().equals("lock")) {
            // TODO Assert locked!=true
            verifyAttributes(batch1, ["properties","locked"],resp,"false")
        } else {
            // TODO Assert locked!=false
            verifyAttributes(batch1, ["properties","locked"],resp,"true")
        }
*/
        /*
        // TODO Redo
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        if (lastOp.toString().equals("lock")) {
            // TODO Assert locked=true
            verifyAttributes(batch1, ["properties","locked"],resp,"true")
        } else {
            // TODO Assert locked=false
            verifyAttributes(batch1, ["properties","locked"],resp,"false")
        }

        // TODO Redo, two or more redos equal one redo
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        if (lastOp.toString().equals("lock")) {
            // TODO Assert locked=true
            verifyAttributes(batch1, ["properties","locked"],resp,"true")
        } else {
            // TODO Assert locked=false
            verifyAttributes(batch1, ["properties","locked"],resp,"false")
        }
        */


        /*
        // Create batch2
        def batch2 = createNBatchWhiteListWidgets (1,g('common'),g('content'), g('widget'),'_',projectIdInTest, contentIdInTest, (containerKey= contentIdInTest) )
        assertEquals(batch2.size(), g('common').widgetTypeList().size(),"Widget batch create failed")

        // Lock batch2
        lockUnlockVerifyBatch (batch2,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"true"])

        // Unlock batch2
        lockUnlockVerifyBatch (batch2,g('common'),contentIdInTest,g('widget'),projectIdInTest,chapterIdInTest,[locked:"false"])

        // Redo verify locked:false
        resp = g('UndoRedo').redo(projectIdInTest)
        assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        verifyAttributes(batch2, ["properties","locked"],resp,"false")

        // TODO It fails here TBD
        //resp = g('UndoRedo').redo(projectIdInTest)
        //assertEquals((resp =  g('content').get(projectIdInTest, contentIdInTest)).status, 200, "fail get content")
        */
        //verifyAttributes(batch2, ["properties","locked"],resp,"true")

        // Delete the project
        resp = g('project').delete(projectIdInTest)
        assertEquals(resp.status, 200, "fail delete project")
        listOfProjectsToRemove.remove(projectNameInTest.toString())
        log.warn("Congratulation, ${projectNameInTest} passed!")
    }

===============
Ignoring versioned files
$ git update-index --assume-unchanged irise.properties 

=====
MAC fn  up/down, page up/down ctrl-fn  left right file beg file end
Mac terminal linux console: ctrl-a home ctrl-e end
VIM ctrl-cmd-a ctrl-cmd-e  gg G 
=====
   /**
     * TODO TASK
     * TODO TASK CURRENT Verify that CHTML or its view can be locked, valid case.
     * TODO TASK Verify copying of chapter also copies the Lock property of widgets, valid case.
     * TODO TASK Verify that the locked widget can be associated to the actions, valid case.
     * TODO TASK Verify that you can lock localRef, valid case. localRef TBD
     * TODO TASK Verify that you cannot lock blacklist items ( menu, tables....), invalid case.
     * TODO TASK Verify creating actions from locked widget, valid case. Actions TBD?
     * TODO TASK
     * TODO TASK
     ﻿* TODO QUESTION At the service layer, do (x,y) change as per the new container?
     * TODO BUG TASK Verify that the locked widgets can be moved, valid case. To change (x,y) or to move to a different container.
     * TODO BUG TASK Verify that locking the container also locks its children, valid case. As per DOD-771.
     * TODO ISSUE see test function. TASK Verify that lock property can be undo/redo, valid case.
     * Undo redo definitions?
     */
=======
Ignore un-versioned files
git config --global core.excludesfile ~/.gitignore_global
vim ~/.gitignore_global
cat ~/.gitignore_global
/Users/zwang/Documents/irise/irise-service-test/irise.properties
.DS_Store
.DS_Store?

===================================

/**
 * TODO DONE Verify that locked widgets can be selected and deleted, valid case.
 * TODO DONE Put common, project, widget, chapter etc in a map: def synchronized getATool (String keyWord)
 * TODO DONE printChapterURLForRestClient (content,projectIdInTest,contentIdInTest,chapterNameInTest)
 * TODO DONE map key String case sensitive? Yes, "a" differs "A" as a key.
 * TODO DONE lock(), unlock()
 * def protected lockUnlockVerifyOneByOne (x,common,containerKey,widget,projectIdInTest,opVector)
 * def protected lockUnlockVerifyBatch (x,common,containerKey,widget,projectIdInTest, chapterIdInTest,opVector)
 * TODO DONE verifyNodeAttributeFromContentResp()
 * TODO DONE verifyNodeAttributeFromContentResp() //A set of of widgets
 * static def verifyAttributes(x, attributesVector,resp,expected)
 * TODO DONE Batch create whiteList widgets: static def createNBatchWhiteListWidgets (N,common,content, widget,tag,projectIdInTest, contentIdInTest, containerKey)
 * TODO DONE TASK Verify that the locked widgets can be cut/copy, valid case: cut/copied if locked still locked.
 * TODO DONE QUESTION // def itinerary = [] //class  println itinerary.getClass() java.util.ArrayList
 * TODO DONE QUESTION Returns false? if (visit[1].equals(chapterIdInTest))
 * println visit[1].getClass() //class org.codehaus.groovy.runtime.GStringImpl, it behaves differently from Java String class
 * TODO DONE QUESTION //?? batchWidgets[i] : new LinkedHashMap<String,?> box i to Integer or String, thus key 'i' not exist rather than retrieve element at position i
 * TODO DONE TASK Verify widgets can be dropped in locked container, valid case.
 * TODO DONE TASK Verify that lock property can be undo/redo, valid case.
 * TODO COMMIT POINT
 * TODO CONSIDERING Refactor getContentIdByChapterName, getChapterIdByChapterName
 * TODO CONSIDERING Test create CONDITIONAL_HTML
 * TODO QUESTION At the service layer, do (x,y) change as per the new container?
 * TODO BUG TASK Verify that the locked widgets can be moved, valid case. To change (x,y) or to move to a different container.
 * TODO BUG TASK Verify that locking the container also locks its children, valid case. As per DOD-771.
 * TODO ISSUE see test function. TASK Verify that lock property can be undo/redo, valid case.
 */
 


215  git remote set-url origin git@github.com:/iRise/irise-service-test
  218   git remote set-url origin git@github.com:wangzhikai/irise-service-test.git

======
Dev log of TestWidgetsLocking 20141014
    /**
     * TODO Done getLevelOneSubNotesIds(): static def getLevelOneSubNotesIds(content,projectId, chapterContentId,containerKey)
     * TODO Done test, groovy synchronized widgetsTypesCounters: synchronized def getAWidgetTypeCount (String type)
     * NOTE: if get method is synchronized, you don't have to use concurrent map or atomic stuff, but get() has to be synchronized
     * NOTE: this consideration is not necessary, since DC-wise widgets counter is not in the testing JVM instance. It tallers this program's cap, namely a distributed synchronized counter.
     * TODO Done QUESTION Java LinkedHashSet can replace a given node, without alternating the iteration sequence.
     * The answer is do not use set, use map instead.
     * TODO Done create standAloneWidgets[type_1, type_2]
     * [deprecated 20141014 BEG]
     * TODO Done Single widget create map:
     * 1. Required root attributes must be provided according to widgetCreateAttributes
     * NOTE: You cannot use addAll or putAll since you have to check required fields.
     * 2. Additional root attributes will be appended
     * 3. Required properties for create will use default
     * 4. Required properties can be changed than default
     * 5. Additional properties can be appended
     * 6. Handling conditional HTML
     * 7. Test create widgets
     * 8. Conditional_HTML create prop
     * 9. Use typesNamesPropsVector
     * [deprecated 20141014 END]
     * TODO Done Single widget create json : static def getSingleWidgetCreateJson(common,containerKey,rootCreateVector,propCreateVector)
     * TODO Done : static def getWidgetMap (common,containerKey,requiredRootAttributes, requiredProps, rootCreateVector,propCreateVector)
     * TODO Done Change set to map<IdAsString,?>
     * TODO Done Create batchWidgets[type_b_3, type_b_4]
     * TODO Done Refactor widgets creation : def getWidgetCreateElement (String tp,String tag,int n)
     * TODO Done Refactor assert resp
     * TODO Done Test java map addAll update all values, append keys new
     * TODO Done getWidgetMap
     * The case of widget creation
     * 1. This case is identified by function parameter widgetNodeInResp is an empty map  [:].
     * 2. Required root attributes are defined in requiredRootAttributes. All values must be provided by map newRootValues, or assert failure.
     * 3. After required root attributes are filled in, additional root attributes can be appended from newRootValues. AddAll should suffice.
     * 4. Required properties will be created from default, passed by parameter requiredProps
     * 5. Required properties will be updated by addAll of newPropValues map
     * The case of widget update
     * 1. This case identified by function parameter widgetNodeInResp is not an empty map.
     * 2.  Required root attributes are defined in requiredRootAttributes.
     * For each key, first try to get it from widgetNodeInResp. If found, the given value can be changed by newRootValues.
     * If not found, try to get it from newRootValues. If either fails, assert failure.
     * 3. After required root attributes are filled in, additional root attributes can be appended from newRootValues. AddAll should suffice.
     * 4. Required properties will be created from default, passed by parameter requiredProps
     * 5. Required properties will be update by values from widgetNodeInResp['properties']. Then addAll from newPropValues.
     * TODO Done Create stand-alone widget, update stand-alone widget
     * TODO Done Verify this method can also find a widgetNodeInResp : static def findAContainerInRespByUUID(node, UUID)
     * TODO Done Given a widget (a node in Resp), update from a new Resp, catch all new stuff, remove deprecated: just replace.
     * TODO Done Single widget update map
     * TODO Done Lock/unlock standAloneWidgets[type_1, type_2], two transactions
     * TODO Done Lock/unlock batchWidgets[type_b_1, type_b_2], one transaction
     * TODO Done Update widget(s) in batch
     * getBatchWidgetsUpdateMap(common,widgetsMap,containerKey,widgetRootUpdateVector,widgetPropUpdateVector)
     * getBatchWidgetsUpdateJson(common,widgetsMap,containerKey,widgetRootUpdateVector,widgetPropUpdateVector)
     * TODO Done Basic lock/unlock on white-list widgets, valid case.
     * TODO Done Verify that multiple widgets can be locked/unlocked at one go, valid case.
     * Lock/unlock batchWidgets[type_b_1, type_b_2], one transaction
     * TODO Done Lock lock assert unlock unlock assert
     * TODO Done
     * TODO Done
     * TODO COMMIT POINT, review and save to tech notes
     * TODO CONSIDERING Put common, project, widget, chapter etc in a map.
     * TODO CONSIDERING Refactor getContentIdByChapterName, getChapterIdByChapterName
     * TODO CONSIDERING Test create CONDITIONAL_HTML
     */
==== Basically, set is not preferably more advantageous than map. 
See LinkedHashSetReplaceTest

 git status | grep 'deleted' | sed 's/deleted://' | xargs -I{} git rm {}
====
#Intellij import suggestion
ALT ENTER


# regex not a character, regex not a literal
[^ \t]println
# regex uncommented println
^[ \t]*println

====HISTORY 20141010 ===
# the mvn bug just remove the ~/.m2
  314  vim ~/.m2/settings.xml 
  315  /Users/zwang/.m2/repository
20141029 Update
 507  mkdir dcmlui
  508  cd dcmlui
  514  git clone git@github.com:/mlui/suite.git
  515  cd suite
  517  git remote show origin
  523   git remote add mlui git@github.com:/mlui/suite.git
  524  git fetch mlui
  525  git checkout --track -b studio54_lite mlui/studio54_lite
  526  git pull
  527  git log
 533  git clone git@github.com:/mlui/dc.git
  534  cd dc
  535  git remote show origin
  536   git remote add mlui git@github.com:/mlui/dc.git
  537  git fetch mlui
  538   git checkout --track -b studio54_lite mlui/studio54_lite
mvn clean install -DskipTests -Dcobertura.skip
   542  git clone git@github.com:/iRise/dev-tools
  
  /Users/zwang/dcmlui/dev-tools/scripts/debug-dc.sh --war /Users/zwang/dcmlui/dc/muse-dc-web/target/muse-dc-web-9.0.5-SNAPSHOT.war --license-file /Users/zwang/dcmlui/dev-tools/scripts/irise.license --debug-port 5005 -Dcom.sun.management.jmxremote 1>>/Users/zwang/dcmlui/dclog.txt 2>> /Users/zwang/dcmlui/dclog.txt &
  499  tail -f /Users/zwang/dcmlui/dclog.txt

   70  cd ../dev-tools/scripts/
   76  git remote set-url origin git@github.com:irise/irise-service-test.git
  183  git add  src/test/groovy/com/irise/testng/featureTests/TestWidgetsGrouping.groovy
  201  cd ../dc
  202  git pull
  203  git remote show origin
  204  history | grep fetch
  217  git fetch mlui
  218  git rebase mlui/studio54_lite
  219  git log -5 --oneline
  220  mvn clean install -DskipTests -Dcobertura.skip
  221  cd ../dev-tools/
  222  git pull
  223  cd scripts/
  224  ls
  225  history | grep debug
  226  /Users/zwang/dcmlui/dev-tools/scripts/debug-dc.sh --war /Users/zwang/dcmlui/dc/muse-dc-web/target/muse-dc-web-9.0.5-SNAPSHOT.war --license-file /Users/zwang/dcmlui/dev-tools/scripts/irise.license --debug-port 5005 -Dcom.sun.management.jmxremote 1>>/Users/zwang/dcmlui/dclog.txt 2>> /Users/zwang/dcmlui/dclog.txt &
  227  tail -f /Users/zwang/dcmlui/dclog.txt 
  228  fg
  229  fg
  313  ls /Users/zwang/.m2/repository
  
   git clone git@github.com:/mlui/suite.git
  324  git checkout --track -b studio54_lite mlui/studio54_lite
  325  git fetch mlui
  326   git remote add mlui git@github.com:/mlui/suite.git
  327  git fetch mlui
  328  git checkout --track -b studio54_lite mlui/studio54_lite
  329  mvn clean install
  330  cd ~/Documents/irise/irise-service-test


  343  git push
  344  ifconfig
  345  vim /etc/hosts
  346  sudo vim /etc/hosts
  347  ping irises-mbp-6
  348  ping irlaeng07.ircorp.com
  349  ifconfig
  350  ping irlaeng07


  355  sudo vim /etc/hosts
  356  ping ie11three

  392  mvn clean install -DskipTests -Dcobertura.skip 
